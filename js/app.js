/** * Cosmic Miner â€” Main Game Logic */ (function () { 'use strict'; const state = { coins: 0, totalCoins: 0, totalTaps: 0, energy: 1000, maxEnergy: 1000, tapPower: 1, energyRegen: 1, level: 1, upgradeLevels: {}, doubleTapActive: false, doubleTapEnd: 0, autoMineActive: false, autoMineEnd: 0, friends: 0, lastOnline: Date.now(), }; const el = { coins: document.getElementById('coins-display'), level: document.getElementById('level-display'), energyFill: document.getElementById('energy-fill'), energyText: document.getElementById('energy-text'), asteroid: document.getElementById('asteroid'), tapParticles: document.getElementById('tap-particles'), perTap: document.getElementById('per-tap'), upgradesList: document.getElementById('upgrades-list'), navBtns: document.querySelectorAll('.nav-btn'), btnShop: document.getElementById('btn-shop'), btnFriends: document.getElementById('btn-friends'), btnStats: document.getElementById('btn-stats'), btnInvite: document.getElementById('btn-invite'), }; const SAVE_KEY = 'cosmic_miner_save'; function save() { state.lastOnline = Date.now(); try { localStorage.setItem(SAVE_KEY, JSON.stringify(state)); } catch (e) { } } function load() { try { const data = localStorage.getItem(SAVE_KEY); if (data) { const saved = JSON.parse(data); Object.assign(state, saved); recalcStats(); const offlineMs = Date.now() - (state.lastOnline || Date.now()); const offlineMinutes = Math.min(offlineMs / 60000, 480); const offlineLevel = state.upgradeLevels['offline_income'] || 0; if (offlineLevel > 0 && offlineMinutes > 1) { const offlineCoins = Math.floor(offlineLevel * 2 * offlineMinutes); state.coins += offlineCoins; state.totalCoins += offlineCoins; if (offlineCoins > 0) { setTimeout(() => showToast(`â›ï¸ ĞÑ„Ğ»Ğ°Ğ¹Ğ½-Ğ´Ğ¾Ğ±Ñ‹Ñ‡Ğ°: +${formatNum(offlineCoins)} ğŸ’`), 500); } } const offlineEnergy = Math.floor(offlineMs / 1000 * state.energyRegen); state.energy = Math.min(state.energy + offlineEnergy, state.maxEnergy); } } catch (e) { } } function recalcStats() { const lvls = state.upgradeLevels; state.tapPower = 1 + (lvls['tap_power'] || 0); state.maxEnergy = 1000 + (lvls['energy_max'] || 0) * 500; state.energyRegen = 1 + (lvls['energy_regen'] || 0); state.level = 1 + Object.values(lvls).reduce((a, b) => a + b, 0); } function formatNum(n) { if (n >= 1_000_000_000) return (n / 1_000_000_000).toFixed(1) + 'B'; if (n >= 1_000_000) return (n / 1_000_000).toFixed(1) + 'M'; if (n >= 1_000) return (n / 1_000).toFixed(1) + 'K'; return Math.floor(n).toString(); } function updateUI() { el.coins.textContent = formatNum(state.coins); el.level.textContent = `Lv. ${state.level}`; const energyPercent = (state.energy / state.maxEnergy) * 100; el.energyFill.style.width = energyPercent + '%'; el.energyText.textContent = `${Math.floor(state.energy)} / ${state.maxEnergy} âš¡`; const effectiveTap = state.doubleTapActive ? state.tapPower * 2 : state.tapPower; el.perTap.textContent = `+${effectiveTap} ğŸ’ Ğ·Ğ° Ñ‚Ğ°Ğ¿${state.doubleTapActive ? ' (x2!)' : ''}`; } function updateStats() { const s = (id) => document.getElementById(id); if (s('stat-taps')) s('stat-taps').textContent = formatNum(state.totalTaps); if (s('stat-mined')) s('stat-mined').textContent = formatNum(state.totalCoins); if (s('stat-level')) s('stat-level').textContent = state.level; if (s('stat-pertap')) s('stat-pertap').textContent = state.tapPower; if (s('stat-friends')) s('stat-friends').textContent = state.friends; } function showToast(msg) { const toast = document.createElement('div'); toast.className = 'toast'; toast.textContent = msg; document.body.appendChild(toast); setTimeout(() => toast.remove(), 2200); } function spawnParticles(x, y, coins) { const num = document.createElement('div'); num.className = 'tap-number'; num.textContent = `+${coins}`; num.style.left = (x - 30) + 'px'; num.style.top = (y - 30) + 'px'; el.tapParticles.appendChild(num); setTimeout(() => num.remove(), 900); const emojis = ['ğŸ’', 'âœ¨', 'â­', 'ğŸ’ ']; for (let i = 0; i < 3; i++) { const p = document.createElement('div'); p.className = 'particle'; p.textContent = emojis[Math.floor(Math.random() * emojis.length)]; p.style.left = x + 'px'; p.style.top = y + 'px'; const angle = Math.random() * Math.PI * 2; const dist = 60 + Math.random() * 60; p.style.setProperty('--tx', `${Math.cos(angle) * dist}px`); p.style.setProperty('--ty', `${Math.sin(angle) * dist}px`); el.tapParticles.appendChild(p); setTimeout(() => p.remove(), 800); } } function handleTap(e) { e.preventDefault(); if (state.energy < 1) { TG.hapticNotification('warning'); showToast('âš¡ ĞĞµÑ‚ ÑĞ½ĞµÑ€Ğ³Ğ¸Ğ¸! ĞŸĞ¾Ğ´Ğ¾Ğ¶Ğ´Ğ¸ Ğ¸Ğ»Ğ¸ ĞºÑƒĞ¿Ğ¸ Ğ±ÑƒÑÑ‚'); return; } let coins = state.tapPower; if (state.doubleTapActive && Date.now() < state.doubleTapEnd) { coins *= 2; } const multiLevel = state.upgradeLevels['multi_tap'] || 0; if (multiLevel > 0 && Math.random() * 100 < Math.min(multiLevel * 5, 50)) { coins *= 2; } const luckyLevel = state.upgradeLevels['lucky_crystal'] || 0; if (luckyLevel > 0 && Math.random() * 100 < Math.min(luckyLevel * 2, 20)) { coins *= 10; showToast('ğŸ’ Ğ ĞµĞ´ĞºĞ¸Ğ¹ ĞºÑ€Ğ¸ÑÑ‚Ğ°Ğ»Ğ»! x10!'); TG.hapticNotification('success'); } state.coins += coins; state.totalCoins += coins; state.totalTaps++; state.energy = Math.max(0, state.energy - 1); TG.hapticImpact('light'); const rect = el.tapParticles.getBoundingClientRect(); let cx, cy; if (e.touches && e.touches.length > 0) { cx = e.touches[0].clientX - rect.left; cy = e.touches[0].clientY - rect.top; } else if (e.changedTouches && e.changedTouches.length > 0) { cx = e.changedTouches[0].clientX - rect.left; cy = e.changedTouches[0].clientY - rect.top; } else { cx = e.clientX - rect.left; cy = e.clientY - rect.top; } spawnParticles(cx, cy, coins); el.asteroid.classList.remove('tapped'); void el.asteroid.offsetWidth; el.asteroid.classList.add('tapped'); updateUI(); } el.asteroid.addEventListener('touchstart', (e) => { for (let i = 0; i < e.touches.length; i++) { handleTap(e); } }, { passive: false }); el.asteroid.addEventListener('mousedown', handleTap); el.asteroid.addEventListener('contextmenu', (e) => e.preventDefault()); setInterval(() => { if (state.energy < state.maxEnergy) { state.energy = Math.min(state.energy + state.energyRegen, state.maxEnergy); updateUI(); } }, 1000); setInterval(save, 5000); setInterval(() => { if (state.doubleTapActive && Date.now() > state.doubleTapEnd) { state.doubleTapActive = false; el.asteroid.classList.remove('double-active'); showToast('âœ¨ x2 Ğ±Ğ¾Ğ½ÑƒÑ Ğ·Ğ°ĞºĞ¾Ğ½Ñ‡Ğ¸Ğ»ÑÑ'); updateUI(); } if (state.autoMineActive && Date.now() > state.autoMineEnd) { state.autoMineActive = false; showToast('ğŸ¤– ĞĞ²Ñ‚Ğ¾-Ğ´Ğ¾Ğ±Ñ‹Ñ‡Ğ° Ğ·Ğ°ĞºĞ¾Ğ½Ñ‡Ğ¸Ğ»Ğ°ÑÑŒ'); } }, 1000); setInterval(() => { if (state.autoMineActive && Date.now() < state.autoMineEnd) { const autoCoins = state.tapPower; state.coins += autoCoins; state.totalCoins += autoCoins; updateUI(); } }, 1000); function renderUpgrades() { el.upgradesList.innerHTML = ''; UPGRADES.forEach(upg => { const level = state.upgradeLevels[upg.id] || 0; const price = getUpgradePrice(upg, level); const canAfford = state.coins >= price; const card = document.createElement('div'); card.className = 'upgrade-card'; card.innerHTML = ` <div class="upgrade-icon">${upg.icon}</div> <div class="upgrade-info"> <h3>${upg.name}</h3> <p>${upg.description}</p> <div class="upgrade-level">Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ ${level} â€¢ ${upg.effectLabel(level)}</div> </div> <button class="upgrade-buy" ${canAfford ? '' : 'disabled'}>${formatNum(price)} ğŸ’</button> `; card.querySelector('.upgrade-buy').addEventListener('click', () => { const currentLevel = state.upgradeLevels[upg.id] || 0; const cost = getUpgradePrice(upg, currentLevel); if (state.coins >= cost) { state.coins -= cost; state.upgradeLevels[upg.id] = currentLevel + 1; recalcStats(); renderUpgrades(); updateUI(); save(); TG.hapticNotification('success'); showToast(`â¬†ï¸ ${upg.name} â†’ Lv.${currentLevel + 1}`); } }); el.upgradesList.appendChild(card); }); } const panels = { mine: null, upgrades: document.getElementById('panel-upgrades'), boosts: document.getElementById('panel-boosts'), friends: document.getElementById('panel-friends'), }; function showPanel(name) { Object.values(panels).forEach(p => { if (p) { p.classList.add('hidden'); p.classList.remove('visible'); } }); if (name !== 'mine' && panels[name]) { panels[name].classList.remove('hidden'); panels[name].classList.add('visible'); if (name === 'upgrades') renderUpgrades(); if (name === 'friends') updateStats(); } el.navBtns.forEach(btn => { btn.classList.toggle('active', btn.dataset.tab === name); }); } el.navBtns.forEach(btn => { btn.addEventListener('click', () => { showPanel(btn.dataset.tab); TG.hapticImpact('light'); }); }); document.querySelectorAll('.panel-close').forEach(btn => { btn.addEventListener('click', () => { showPanel('mine'); }); }); el.btnShop.addEventListener('click', () => showPanel('upgrades')); el.btnFriends.addEventListener('click', () => showPanel('friends')); el.btnStats.addEventListener('click', () => { updateStats(); const statsPanel = document.getElementById('panel-stats'); statsPanel.classList.remove('hidden'); statsPanel.classList.add('visible'); }); document.querySelector('#panel-stats .panel-close').addEventListener('click', () => { const statsPanel = document.getElementById('panel-stats'); statsPanel.classList.add('hidden'); statsPanel.classList.remove('visible'); }); document.querySelectorAll('.boost-buy').forEach(btn => { btn.addEventListener('click', () => { const card = btn.closest('.boost-card'); const boostType = card.dataset.boost; const stars = parseInt(btn.dataset.stars); if (typeof TG !== 'undefined' && TG.app) { TG.app.sendData(JSON.stringify({ action: 'buy_boost', boost: boostType, stars: stars, user_id: TG.getUserId(), })); } applyBoost(boostType); }); }); function applyBoost(type) { switch (type) { case 'energy-refill': state.energy = state.maxEnergy; showToast('âš¡ Ğ­Ğ½ĞµÑ€Ğ³Ğ¸Ñ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°!'); TG.hapticNotification('success'); break; case 'double-tap': state.doubleTapActive = true; state.doubleTapEnd = Date.now() + 30 * 60 * 1000; el.asteroid.classList.add('double-active'); showToast('âœ¨ x2 Ğ´Ğ¾Ñ…Ğ¾Ğ´ Ğ½Ğ° 30 Ğ¼Ğ¸Ğ½ÑƒÑ‚!'); TG.hapticNotification('success'); break; case 'auto-mine': state.autoMineActive = true; state.autoMineEnd = Date.now() + 60 * 60 * 1000; showToast('ğŸ¤– ĞĞ²Ñ‚Ğ¾-Ğ´Ğ¾Ğ±Ñ‹Ñ‡Ğ° Ğ½Ğ° 1 Ñ‡Ğ°Ñ!'); TG.hapticNotification('success'); break; } updateUI(); save(); } el.btnInvite.addEventListener('click', () => { const userId = TG.getUserId(); const text = 'â›ï¸ Cosmic Miner â€” Ñ‚Ğ°Ğ¿Ğ°Ğ¹ Ğ°ÑÑ‚ĞµÑ€Ğ¾Ğ¸Ğ´, Ğ´Ğ¾Ğ±Ñ‹Ğ²Ğ°Ğ¹ ĞºÑ€Ğ¸ÑÑ‚Ğ°Ğ»Ğ»Ñ‹! ğŸ’\nĞ˜Ğ³Ñ€Ğ°Ğ¹ Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ğ¾ Ğ² Telegram!'; if (TG.app) { const shareUrl = `https://t.me/share/url?url=${encodeURIComponent('Ğ˜Ğ³Ñ€Ğ°Ğ¹ Ğ² Cosmic Miner!')}&text=${encodeURIComponent(text)}`; TG.app.openTelegramLink(shareUrl); } else { showToast('ğŸ“¤ Ğ¡ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾! ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒ Ğ´Ñ€ÑƒĞ³Ñƒ'); } TG.hapticImpact('medium'); }); function checkReferral() { const ref = TG.getStartParam(); if (ref && ref.startsWith('ref_')) { const refKey = `cosmic_ref_${TG.getUserId()}`; if (!localStorage.getItem(refKey)) { state.coins += 2500; state.totalCoins += 2500; localStorage.setItem(refKey, 'done'); showToast('ğŸ Ğ‘Ğ¾Ğ½ÑƒÑ Ğ·Ğ° Ğ¿Ñ€Ğ¸Ğ³Ğ»Ğ°ÑˆĞµĞ½Ğ¸Ğµ: +2500 ğŸ’'); save(); updateUI(); } } } load(); updateUI(); renderUpgrades(); checkReferral(); window.addEventListener('beforeunload', save); window.addEventListener('pagehide', save); if (TG.app) { window.addEventListener('visibilitychange', () => { if (document.hidden) save(); }); } console.log('â›ï¸ Cosmic Miner initialized!'); })();
